#!/bin/bash

set -euo pipefail

VERSION="1.0.0"
VERBOSE=false
COMMAND=""
TARGET_ARG=""
FORCE=false

PROMPTS_HOME="${PROMPTR_DIR:-$HOME/.prompts}"
REPO_BIN="$PROMPTS_HOME/bin/promptr"
INSTALL_BIN="$HOME/.local/bin/promptr"
CONFIG_DIR="$HOME/.config/promptr"
LINKS_FILE="$CONFIG_DIR/links"
PREFIX_FILE="$CONFIG_DIR/prefix"
FILENAME_PREFIX_DEFAULT="promptr"
FILENAME_PREFIX="$FILENAME_PREFIX_DEFAULT"
ANTIGRAVITY_DIR="$HOME/.gemini/antigravity/global_workflows"
CODEX_DIR="$HOME/.codex/prompts"
COPILOT_DIR="$HOME/.config/Code/User/prompts"
DROID_DIR="$HOME/.factory/commands"
CURSOR_DIR="$HOME/.cursor/commands"
WINDSURF_DIR="$HOME/.codeium/windsurf/global_workflows"
GEMINI_COMMANDS_DIR="$HOME/.gemini/commands"

if [ "$(uname)" = "Darwin" ]; then
    COPILOT_DIR="$HOME/Library/Application Support/Code/User/prompts"
fi

log_verbose() {
    if [ "$VERBOSE" = true ]; then
        echo "$(date '+%Y-%m-%d %H:%M:%S'): $*"
    fi
}

show_help() {
    cat <<EOF
promptr - Prompt management tool v$VERSION

A CLI tool for managing and syncing prompt collections via Git.
Prompts live in $PROMPTS_HOME

Commands:
    update          Fetch and merge latest prompts from the remote repository
    self-update     Update the promptr script itself
    link            Create links for specific target or all (antigravity, codex, copilot, droid, gemini, opencode, claude, cursor, windsurf, roo, all)
    unlink          Remove links for specific target or all (antigravity, codex, copilot, droid, gemini, opencode, claude, cursor, windsurf, roo, all)

Link flags:
    --force         Remove existing destination symlink before recreating

Global flags:
    --version       Show version
    --help          Show this help message
    --verbose       Enable verbose logging

Usage: promptr [flags] [command] [flags]
EOF
}

show_version() {
    echo "promptr version $VERSION - Prompt collection manager."
}

require_repo() {
    if [ ! -d "$PROMPTS_HOME/.git" ]; then
        echo "❌ Prompt repository not found at $PROMPTS_HOME. Set PROMPTR_DIR to your clone (default ~/.prompts) or rerun the setup script with your repo URL."
        exit 1
    fi
}

check_self_loop() {
    local source_dir=$1
    local self_loop_link="$source_dir/$(basename "$source_dir")"

    if [ -L "$self_loop_link" ] && [ "$(readlink "$self_loop_link")" = "$source_dir" ]; then
        echo "❌ Found recursive symlink at $self_loop_link; remove it with: rm $self_loop_link"
        return 1
    fi

    return 0
}

ensure_config_dir() {
    mkdir -p "$CONFIG_DIR"
}

strip_trailing_dashes() {
    local value=$1
    while [ "${value%"-"}" != "$value" ]; do
        value="${value%"-"}"
    done
    echo "$value"
}

load_filename_prefix() {
    if [ -n "${PROMPTR_PREFIX:-}" ]; then
        local normalized
        normalized=$(strip_trailing_dashes "$PROMPTR_PREFIX")
        if [ -z "$normalized" ]; then
            normalized="$FILENAME_PREFIX_DEFAULT"
        fi
        ensure_config_dir
        echo -n "$normalized" >"$PREFIX_FILE"
        echo "$normalized"
        return
    fi

    if [ -f "$PREFIX_FILE" ]; then
        local stored_prefix
        stored_prefix=$(strip_trailing_dashes "$(cat "$PREFIX_FILE")")
        if [ -n "$stored_prefix" ]; then
            echo "$stored_prefix"
            return
        fi
    fi

    echo "$FILENAME_PREFIX_DEFAULT"
}

FILENAME_PREFIX="$(load_filename_prefix)"
FILENAME_PREFIX_DASHED=""
if [ -n "$FILENAME_PREFIX" ]; then
    FILENAME_PREFIX_DASHED="${FILENAME_PREFIX}-"
fi

is_target_linked() {
    local target=$1

    if [ ! -f "$LINKS_FILE" ]; then
        return 1
    fi

    grep -Fxq "$target" "$LINKS_FILE"
}

record_linked_target() {
    local target=$1

    ensure_config_dir

    if ! is_target_linked "$target"; then
        echo "$target" >>"$LINKS_FILE"
    fi
}

clear_linked_target() {
    local target=$1

    if [ ! -f "$LINKS_FILE" ]; then
        return 0
    fi

    local tmp_file
    tmp_file="$(mktemp "$LINKS_FILE.XXXXXX")"

    grep -Fxv "$target" "$LINKS_FILE" >"$tmp_file" || true
    mv "$tmp_file" "$LINKS_FILE"
}

clear_all_linked_targets() {
    rm -f "$LINKS_FILE"
}

validate_source_dir() {
    local source_dir=$1

    if [ ! -d "$source_dir" ]; then
        echo "❌ Cannot create symlink: source directory $source_dir is missing"
        return 1
    fi

    if [ -L "$source_dir" ]; then
        echo "❌ Cannot create symlink: $source_dir is itself a symlink (nested symlinks not allowed)"
        return 1
    fi

    check_self_loop "$source_dir"
}

guard_target_path() {
    local target_dir=$1
    local source_dir=$2

    if [ "$target_dir" = "$source_dir" ]; then
        echo "❌ Cannot link $target_dir to itself (would create recursive symlink)"
        return 1
    fi

    case "$target_dir" in
        "$source_dir"|"$source_dir"/*)
            echo "❌ Cannot create symlink inside $source_dir (would create recursive link at $target_dir)"
            return 1
            ;;
    esac

    local check_dir="$target_dir"
    while [ "$check_dir" != "/" ] && [ "$check_dir" != "." ] && [ "$check_dir" != ".." ]; do
        if [ -L "$check_dir" ]; then
            echo "❌ Cannot create symlink: path $target_dir contains symlink at $check_dir (would create nested symlinks)"
            return 1
        fi
        check_dir=$(dirname "$check_dir")
    done

    return 0
}

prepare_destination() {
    local destination=$1

    if [ -e "$destination" ] && [ "$FORCE" = false ]; then
        echo "❌ $destination already exists. Use --force to replace an existing symlink."
        return 1
    fi

    if [ "$FORCE" = true ] && [ -e "$destination" ] && [ ! -L "$destination" ]; then
        echo "❌ Cannot use --force: $destination exists and is not a symlink (refusing to remove)"
        return 1
    fi

    if [ "$FORCE" = true ] && [ -L "$destination" ]; then
        rm "$destination" || {
            echo "❌ Failed to remove existing symlink at $destination (needed for --force)"
            return 1
        }
    fi
}

create_symlink() {
    local target_dir=$1
    local link_name=$2
    local source_dir="$PROMPTS_HOME"
    local destination="$target_dir/$link_name"

    validate_source_dir "$source_dir" || return 1
    guard_target_path "$target_dir" "$source_dir" || return 1
    prepare_destination "$destination" || return 1

    mkdir -p "$target_dir"
    ln -s "$source_dir" "$destination"
    check_self_loop "$source_dir" || return 1
    echo "✅ Symlink created/updated at $target_dir/$link_name"
}

copy_antigravity_files() {
    local dest_dir="$ANTIGRAVITY_DIR"

    mkdir -p "$dest_dir"

    local files
    files=$(find "$PROMPTS_HOME" -name "*.md" ! -name "README.md" -type f)
    if [ -z "$files" ]; then
        echo "⚠️  No *.md files found in $PROMPTS_HOME"
        return 0
    fi

    echo "$files" | while IFS= read -r file; do
        local dest_file="$dest_dir/${FILENAME_PREFIX_DASHED}$(basename "$file")"
        if [ "$FORCE" = true ] && [ -e "$dest_file" ]; then
            rm -f "$dest_file"
        fi
        cp "$file" "$dest_file"
    done

    record_linked_target "antigravity"
    echo "✅ Copied *.md files to $dest_dir"
}

copy_roo_files() {
    local dest_dir="$HOME/.roo/commands"

    if [ "$FORCE" = true ]; then
        rm -rf "$dest_dir"/*
    fi

    mkdir -p "$dest_dir"

    local files
    files=$(find "$PROMPTS_HOME" -name "*.md" ! -name "README.md" -type f)
    if [ -z "$files" ]; then
        echo "⚠️  No *.md files found in $PROMPTS_HOME"
        return 0
    fi

    echo "$files" | while IFS= read -r file; do
        local dest_file="$dest_dir/${FILENAME_PREFIX_DASHED}$(basename "$file")"
        cp "$file" "$dest_file"
    done

    echo "✅ Copied prefixed *.md files to $dest_dir"
}

copy_codex_files() {
    local dest_dir="$CODEX_DIR"

    mkdir -p "$dest_dir"

    local files
    files=$(find "$PROMPTS_HOME" -name "*.md" ! -name "README.md" -type f)
    if [ -z "$files" ]; then
        echo "⚠️  No *.md files found in $PROMPTS_HOME"
        return 0
    fi

    echo "$files" | while IFS= read -r file; do
        local dest_file="$dest_dir/${FILENAME_PREFIX_DASHED}$(basename "$file")"
        if [ "$FORCE" = true ] && [ -e "$dest_file" ]; then
            rm -f "$dest_file"
        fi
        cp "$file" "$dest_file"
    done

    record_linked_target "codex"
    echo "✅ Copied prefixed *.md files to $dest_dir"
}

copy_droid_files() {
    local dest_dir="$DROID_DIR"

    mkdir -p "$dest_dir"

    local files
    files=$(find "$PROMPTS_HOME" -name "*.md" ! -name "README.md" -type f)
    if [ -z "$files" ]; then
        echo "⚠️  No *.md files found in $PROMPTS_HOME"
        return 0
    fi

    echo "$files" | while IFS= read -r file; do
        local dest_file="$dest_dir/${FILENAME_PREFIX_DASHED}$(basename "$file")"
        if [ "$FORCE" = true ] && [ -e "$dest_file" ]; then
            rm -f "$dest_file"
        fi
        cp "$file" "$dest_file"
    done

    record_linked_target "droid"
    echo "✅ Copied prefixed *.md files to $dest_dir"
}

extract_description() {
    local file=$1
    awk '
    BEGIN { in_front=0 }
    NR==1 && $0 ~ /^---[ \t]*$/ { in_front=1; next }
    in_front && $0 ~ /^---[ \t]*$/ { exit }
    in_front && $0 ~ /^description:[ \t]*/ {
        line=$0
        sub(/^description:[ \t]*/, "", line)
        gsub(/^"[ \t]*/, "", line)
        gsub(/"[ \t]*$/, "", line)
        print line
        exit
    }
    ' "$file"
}

extract_body() {
    local file=$1
    awk '
    BEGIN { in_front=0 }
    NR==1 && $0 ~ /^---[ \t]*$/ { in_front=1; next }
    in_front && $0 ~ /^---[ \t]*$/ { in_front=0; next }
    { if (!in_front) print }
    ' "$file"
}

escape_toml_basic() {
    sed 's/\\/\\\\/g; s/"/\\"/g'
}

escape_toml_multiline() {
    sed 's/\\/\\\\/g; s/\"\"\"/\\"""/g'
}

write_gemini_toml() {
    local source_file=$1
    local dest_file=$2

    local description
    description=$(extract_description "$source_file")
    local body
    body=$(extract_body "$source_file")

    local escaped_desc
    escaped_desc=$(printf "%s" "$description" | escape_toml_basic)
    local escaped_body
    escaped_body=$(printf "%s" "$body" | escape_toml_multiline)

    cat >"$dest_file" <<EOF
description = "$escaped_desc"
prompt = """$escaped_body
"""
EOF
}

copy_gemini_files() {
    local dest_dir="$GEMINI_COMMANDS_DIR"

    mkdir -p "$dest_dir"

    local files
    files=$(find "$PROMPTS_HOME" -name "*.md" ! -name "README.md" -type f)
    if [ -z "$files" ]; then
        echo "⚠️  No *.md files found in $PROMPTS_HOME"
        return 0
    fi

    echo "$files" | while IFS= read -r file; do
        local base_no_ext
        base_no_ext=$(basename "$file" .md)
        local dest_file="$dest_dir/${FILENAME_PREFIX_DASHED}${base_no_ext}.toml"
        if [ "$FORCE" = true ] && [ -e "$dest_file" ]; then
            rm -f "$dest_file"
        fi
        write_gemini_toml "$file" "$dest_file"
    done

    record_linked_target "gemini"
    echo "✅ Generated Gemini TOML files in $dest_dir"
}

copy_windsurf_files() {
    local dest_dir="$WINDSURF_DIR"

    mkdir -p "$dest_dir"

    local files
    files=$(find "$PROMPTS_HOME" -name "*.md" ! -name "README.md" -type f)
    if [ -z "$files" ]; then
        echo "⚠️  No *.md files found in $PROMPTS_HOME"
        return 0
    fi

    echo "$files" | while IFS= read -r file; do
        local dest_file="$dest_dir/${FILENAME_PREFIX_DASHED}$(basename "$file")"
        if [ "$FORCE" = true ] && [ -e "$dest_file" ]; then
            rm -f "$dest_file"
        fi
        cp "$file" "$dest_file"
    done

    record_linked_target "windsurf"
    echo "✅ Copied prefixed *.md files to $dest_dir"
}

copy_copilot_files() {
    local dest_dir="$COPILOT_DIR"

    mkdir -p "$dest_dir"

    local files
    files=$(find "$PROMPTS_HOME" -name "*.md" ! -name "README.md" -type f)
    if [ -z "$files" ]; then
        echo "⚠️  No *.md files found in $PROMPTS_HOME"
        return 0
    fi

    echo "$files" | while IFS= read -r file; do
        local name_no_ext
        name_no_ext=$(basename "$file" .md)
        local dest_file="$dest_dir/${FILENAME_PREFIX_DASHED}$name_no_ext.prompt.md"
        if [ "$FORCE" = true ] && [ -e "$dest_file" ]; then
            rm -f "$dest_file"
        fi
        cp "$file" "$dest_file"
    done

    record_linked_target "copilot"
    echo "✅ Copied prefixed *.prompt.md files to \"$dest_dir\""
}

unlink_antigravity() {
    local dest_dir="$ANTIGRAVITY_DIR"

    if [ ! -d "$dest_dir" ]; then
        return 0
    fi

    local files
    files=$(find "$PROMPTS_HOME" -name "*.md" ! -name "README.md" -type f)
    if [ -z "$files" ]; then
        return 0
    fi

    echo "$files" | while IFS= read -r file; do
        local base_name
        base_name="$(basename "$file")"
        local dest_file_prefixed="$dest_dir/${FILENAME_PREFIX_DASHED}$base_name"
        local dest_file_plain="$dest_dir/$base_name"

        if [ -e "$dest_file_prefixed" ]; then
            rm -f "$dest_file_prefixed"
        fi

        if [ -n "$FILENAME_PREFIX_DASHED" ] && [ -e "$dest_file_plain" ] && [ "$dest_file_plain" != "$dest_file_prefixed" ]; then
            rm -f "$dest_file_plain"
        fi
    done

    clear_linked_target "antigravity"
    echo "✅ Removed AntiGravity prompt copies from $dest_dir"
}

unlink_roo() {
    local dest_dir="$HOME/.roo/commands"

    if [ ! -d "$dest_dir" ]; then
        return 0
    fi

    local files
    files=$(find "$PROMPTS_HOME" -name "*.md" ! -name "README.md" -type f)
    if [ -z "$files" ]; then
        return 0
    fi

    echo "$files" | while IFS= read -r file; do
        local base_name
        base_name="$(basename "$file")"
        local dest_file_prefixed="$dest_dir/${FILENAME_PREFIX_DASHED}$base_name"
        local dest_file_plain="$dest_dir/$base_name"

        if [ -e "$dest_file_prefixed" ]; then
            rm -f "$dest_file_prefixed"
        fi

        if [ -n "$FILENAME_PREFIX_DASHED" ] && [ -e "$dest_file_plain" ] && [ "$dest_file_plain" != "$dest_file_prefixed" ]; then
            rm -f "$dest_file_plain"
        fi
    done

    clear_linked_target "roo"
    echo "✅ Removed Roo prompt copies from $dest_dir"
}

unlink_codex() {
    local dest_dir="$CODEX_DIR"

    if [ ! -d "$dest_dir" ]; then
        clear_linked_target "codex"
        return 0
    fi

    local files
    files=$(find "$PROMPTS_HOME" -name "*.md" ! -name "README.md" -type f)
    if [ -n "$files" ]; then
        echo "$files" | while IFS= read -r file; do
            local dest_file="$dest_dir/${FILENAME_PREFIX_DASHED}$(basename "$file")"
            if [ -e "$dest_file" ]; then
                rm -f "$dest_file"
            fi
        done
    fi

    clear_linked_target "codex"
    echo "✅ Removed Codex prompt copies from $dest_dir"
}

unlink_droid() {
    local dest_dir="$DROID_DIR"

    if [ ! -d "$dest_dir" ]; then
        clear_linked_target "droid"
        return 0
    fi

    local files
    files=$(find "$PROMPTS_HOME" -name "*.md" ! -name "README.md" -type f)
    if [ -n "$files" ]; then
        echo "$files" | while IFS= read -r file; do
            local dest_file="$dest_dir/${FILENAME_PREFIX_DASHED}$(basename "$file")"
            if [ -e "$dest_file" ]; then
                rm -f "$dest_file"
            fi
        done
    fi

    clear_linked_target "droid"
    echo "✅ Removed Droid prompt copies from $dest_dir"
}

unlink_windsurf() {
    local dest_dir="$WINDSURF_DIR"

    if [ ! -d "$dest_dir" ]; then
        clear_linked_target "windsurf"
        return 0
    fi

    local files
    files=$(find "$PROMPTS_HOME" -name "*.md" ! -name "README.md" -type f)
    if [ -n "$files" ]; then
        echo "$files" | while IFS= read -r file; do
            local dest_file="$dest_dir/${FILENAME_PREFIX_DASHED}$(basename "$file")"
            if [ -e "$dest_file" ]; then
                rm -f "$dest_file"
            fi
        done
    fi

    clear_linked_target "windsurf"
    echo "✅ Removed Windsurf prompt copies from $dest_dir"
}

unlink_gemini() {
    local dest_dir="$GEMINI_COMMANDS_DIR"

    if [ ! -d "$dest_dir" ]; then
        clear_linked_target "gemini"
        return 0
    fi

    local files
    files=$(find "$PROMPTS_HOME" -name "*.md" ! -name "README.md" -type f)
    if [ -n "$files" ]; then
        echo "$files" | while IFS= read -r file; do
            local base_no_ext
            base_no_ext=$(basename "$file" .md)
            local dest_file="$dest_dir/${FILENAME_PREFIX_DASHED}${base_no_ext}.toml"
            if [ -e "$dest_file" ]; then
                rm -f "$dest_file"
            fi
        done
    fi

    clear_linked_target "gemini"
    echo "✅ Removed Gemini TOML files from $dest_dir"
}

unlink_copilot() {
    local dest_dir="$COPILOT_DIR"

    if [ ! -d "$dest_dir" ]; then
        clear_linked_target "copilot"
        return 0
    fi

    local files
    files=$(find "$PROMPTS_HOME" -name "*.md" ! -name "README.md" -type f)
    if [ -n "$files" ]; then
        echo "$files" | while IFS= read -r file; do
            local name_no_ext
            name_no_ext=$(basename "$file" .md)
            local dest_file="$dest_dir/${FILENAME_PREFIX_DASHED}$name_no_ext.prompt.md"
            if [ -e "$dest_file" ]; then
                rm -f "$dest_file"
            fi
        done
    fi

    clear_linked_target "copilot"
    echo "✅ Removed Copilot prompt copies from \"$dest_dir\""
}

cmd_update() {
    require_repo

    log_verbose "Updating prompt repository at $PROMPTS_HOME..."
    if [ "$VERBOSE" = true ]; then
        git -C "$PROMPTS_HOME" status --short
    fi

    if git -C "$PROMPTS_HOME" pull ${VERBOSE:+--verbose}; then
        if is_target_linked "antigravity"; then
            log_verbose "Refreshing AntiGravity prompt copies..."
            copy_antigravity_files
        fi
        if is_target_linked "roo"; then
            log_verbose "Refreshing Roo prompt copies..."
            copy_roo_files
        fi
        if is_target_linked "copilot"; then
            log_verbose "Refreshing Copilot prompt copies..."
            copy_copilot_files
        fi
        if is_target_linked "droid"; then
            log_verbose "Refreshing Droid prompt copies..."
            copy_droid_files
        fi
        if is_target_linked "windsurf"; then
            log_verbose "Refreshing Windsurf prompt copies..."
            copy_windsurf_files
        fi
        if is_target_linked "gemini"; then
            log_verbose "Refreshing Gemini TOML files..."
            copy_gemini_files
        fi
        if is_target_linked "codex"; then
            log_verbose "Refreshing Codex prompt copies..."
            copy_codex_files
        fi
        echo "✅ Prompts updated successfully at $PROMPTS_HOME."
    else
        echo "❌ Failed to update prompts. Check your connection and repository permissions."
        exit 1
    fi
}

cmd_self_update() {
    mkdir -p "$(dirname "$INSTALL_BIN")"

    local cli_url="${PROMPTR_CLI_URL:-https://raw.githubusercontent.com/mul14/promptr/master/bin/promptr}"
    echo "Downloading promptr from $cli_url ..."

    if command -v curl >/dev/null 2>&1; then
        curl -fsSL "$cli_url" -o "$INSTALL_BIN" || {
            echo "❌ Failed to download CLI from $cli_url. Set PROMPTR_CLI_URL to a valid URL and retry."
            exit 1
        }
    elif command -v wget >/dev/null 2>&1; then
        wget -qO "$INSTALL_BIN" "$cli_url" || {
            echo "❌ Failed to download CLI from $cli_url. Set PROMPTR_CLI_URL to a valid URL and retry."
            exit 1
        }
    else
        echo "❌ Neither curl nor wget is available to download the CLI."
        exit 1
    fi

    chmod +x "$INSTALL_BIN" || {
        echo "❌ Failed to set execute permission on $INSTALL_BIN"
        exit 1
    }
    echo "✅ Promptr script updated at $INSTALL_BIN."
}

show_link_usage() {
    echo "❌ Usage: promptr link [--force] <target|all>"
    echo "Supported targets:"
    echo "  antigravity    Copy prompts to ~/.gemini/antigravity/global_workflows"
    echo "  codex          Copy prompts to ~/.codex/prompts"
    echo "  copilot        Copy prompts to Copilot prompts dir"
    echo "  droid          Copy prompts to ~/.factory/commands"
    echo "  gemini         Copy prompts to ~/.gemini/commands as TOML"
    echo "  opencode       Symlink ~/.prompts to ~/.config/opencode/command/<prefix>"
    echo "  claude         Symlink ~/.prompts to ~/.claude/commands/<prefix>"
    echo "  cursor         Symlink ~/.prompts to ~/.cursor/commands/<prefix>"
    echo "  windsurf       Copy prompts to ~/.codeium/windsurf/global_workflows"
    echo "  roo            Copy prompts to ~/.roo/commands"
    echo "  all            Link all targets"
}

cmd_link() {
    require_repo

    if [ -z "$TARGET_ARG" ]; then
        show_link_usage
        exit 1
    fi

    local status=0
    case $TARGET_ARG in
        all)
            copy_antigravity_files || status=1
            create_symlink "$HOME/.config/opencode/command" "$FILENAME_PREFIX" && record_linked_target "opencode" || status=1
            create_symlink "$HOME/.claude/commands" "$FILENAME_PREFIX" && record_linked_target "claude" || status=1
            create_symlink "$CURSOR_DIR" "$FILENAME_PREFIX" && record_linked_target "cursor" || status=1
            copy_roo_files && record_linked_target "roo" || status=1
            copy_droid_files || status=1
            copy_copilot_files || status=1
            copy_gemini_files || status=1
            copy_windsurf_files || status=1
            copy_codex_files || status=1
            ;;
        antigravity)
            copy_antigravity_files || status=1
            ;;
        codex)
            copy_codex_files || status=1
            ;;
        droid)
            copy_droid_files || status=1
            ;;
        copilot)
            copy_copilot_files || status=1
            ;;
        gemini)
            copy_gemini_files || status=1
            ;;
        opencode)
            create_symlink "$HOME/.config/opencode/command" "$FILENAME_PREFIX" && record_linked_target "opencode" || status=1
            ;;
        claude)
            create_symlink "$HOME/.claude/commands" "$FILENAME_PREFIX" && record_linked_target "claude" || status=1
            ;;
        cursor)
            create_symlink "$CURSOR_DIR" "$FILENAME_PREFIX" && record_linked_target "cursor" || status=1
            ;;
        windsurf)
            copy_windsurf_files || status=1
            ;;
        roo)
            copy_roo_files && record_linked_target "roo" || status=1
            ;;
        *)
            echo "❌ Unknown target: $TARGET_ARG"
            show_link_usage
            exit 1
            ;;
    esac

    if [ $status -ne 0 ]; then
        exit 1
    fi
}

show_unlink_usage() {
    echo "❌ Usage: promptr unlink <target|all>"
    echo "Supported targets:"
    echo "  antigravity    Remove copied prompts from ~/.gemini/antigravity/global_workflows"
    echo "  codex          Remove prefixed copied prompts from ~/.codex/prompts (uses configured prefix, default promptr)"
    echo "  copilot        Remove prefixed copied prompts (.prompt.md) from Copilot prompts directory (~/Library/Application Support/Code/User/prompts on macOS, ~/.config/Code/User/prompts on Linux) using configured prefix"
    echo "  droid          Remove prefixed copied prompts from ~/.factory/commands (uses configured prefix, default promptr)"
    echo "  gemini         Remove TOML prompts from ~/.gemini/commands (uses configured prefix, default promptr)"
    echo "  opencode       Remove symlink at ~/.config/opencode/command/<prefix>"
    echo "  claude         Remove symlink at ~/.claude/commands/<prefix>"
    echo "  cursor         Remove symlink at ~/.cursor/commands/<prefix>"
    echo "  windsurf       Remove prefixed copied prompts from ~/.codeium/windsurf/global_workflows"
    echo "  roo            Remove copied prompts from ~/.roo/commands (prefixed with configured prefix)"
    echo "  all            Remove all managed links and copies"
}

remove_symlink_target() {
    local target_dir=$1
    local link_name=$2
    local destination="$target_dir/$link_name"

    if [ -L "$destination" ]; then
        rm "$destination" || {
            echo "❌ Failed to remove symlink at $destination"
            return 1
        }
        echo "✅ Removed symlink at $destination"
    fi
}

cmd_unlink() {
    if [ -z "$TARGET_ARG" ]; then
        show_unlink_usage
        exit 1
    fi

    local status=0
    case $TARGET_ARG in
        all)
            unlink_antigravity || status=1
            remove_symlink_target "$HOME/.config/opencode/command" "$FILENAME_PREFIX" || status=1
            clear_linked_target "opencode"
            remove_symlink_target "$HOME/.claude/commands" "$FILENAME_PREFIX" || status=1
            clear_linked_target "claude"
            remove_symlink_target "$CURSOR_DIR" "$FILENAME_PREFIX" || status=1
            clear_linked_target "cursor"
            unlink_roo || status=1
            unlink_droid || status=1
            unlink_gemini || status=1
            unlink_windsurf || status=1
            unlink_copilot || status=1
            unlink_codex || status=1
            clear_all_linked_targets
            ;;
        antigravity)
            unlink_antigravity || status=1
            ;;
        codex)
            unlink_codex || status=1
            ;;
        droid)
            unlink_droid || status=1
            ;;
        gemini)
            unlink_gemini || status=1
            ;;
        windsurf)
            unlink_windsurf || status=1
            ;;
        copilot)
            unlink_copilot || status=1
            ;;
        opencode)
            remove_symlink_target "$HOME/.config/opencode/command" "$FILENAME_PREFIX" || status=1
            clear_linked_target "opencode"
            ;;
        claude)
            remove_symlink_target "$HOME/.claude/commands" "$FILENAME_PREFIX" || status=1
            clear_linked_target "claude"
            ;;
        cursor)
            remove_symlink_target "$CURSOR_DIR" "$FILENAME_PREFIX" || status=1
            clear_linked_target "cursor"
            ;;
        roo)
            unlink_roo || status=1
            ;;
        *)
            echo "❌ Unknown target: $TARGET_ARG"
            show_unlink_usage
            exit 1
            ;;
    esac

    if [ $status -ne 0 ]; then
        exit 1
    fi
}

parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --version)
                show_version
                exit 0
                ;;
            --help|-h)
                show_help
                exit 0
                ;;
            --verbose)
                VERBOSE=true
                shift
                ;;
            *)
                COMMAND=$1
                shift
                while [[ $# -gt 0 ]]; do
                    case $1 in
                        --verbose)
                            VERBOSE=true
                            shift
                            ;;
                        --force)
                            FORCE=true
                            shift
                            ;;
                        -*)
                            echo "❌ Unknown flag: $1"
                            echo "Run 'promptr --help' for usage."
                            exit 1
                            ;;
                        *)
                            if [ -z "$TARGET_ARG" ]; then
                                TARGET_ARG=$1
                                shift
                            else
                                echo "❌ Unexpected argument: $1"
                                echo "Run 'promptr --help' for usage."
                                exit 1
                            fi
                            ;;
                    esac
                done
                break
                ;;
        esac
    done
}

main() {
    parse_args "$@"

    case "$COMMAND" in
        "")
            show_help
            exit 0
            ;;
        update)
            cmd_update
            ;;
        self-update)
            cmd_self_update
            ;;
        link)
            cmd_link
            ;;
        unlink)
            cmd_unlink
            ;;
        *)
            echo "❌ Unknown command: $COMMAND"
            echo "Run 'promptr --help' for available commands."
            exit 1
            ;;
    esac
}

main "$@"
