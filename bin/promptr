#!/bin/bash

set -euo pipefail

VERSION="1.0.0"
VERBOSE=false
COMMAND=""
TARGET_ARG=""
FORCE=false

PROMPTS_HOME="${PROMPTR_DIR:-$HOME/.prompts}"
REPO_BIN="$PROMPTS_HOME/bin/promptr"
INSTALL_BIN="$HOME/.local/bin/promptr"
CONFIG_DIR="$HOME/.config/promptr"
LINKS_FILE="$CONFIG_DIR/links"
PREFIX_FILE="$CONFIG_DIR/prefix"
FILENAME_PREFIX_DEFAULT="promptr-"
FILENAME_PREFIX="$FILENAME_PREFIX_DEFAULT"
ANTIGRAVITY_DIR="$HOME/.gemini/antigravity/global_workflows"
CODEX_DIR="$HOME/.codex/prompts"
COPILOT_DIR="$HOME/.config/Code/User/prompts"
DROID_DIR="$HOME/.factory/commands"

if [ "$(uname)" = "Darwin" ]; then
    COPILOT_DIR="$HOME/Library/Application Support/Code/User/prompts"
fi

log_verbose() {
    if [ "$VERBOSE" = true ]; then
        echo "$(date '+%Y-%m-%d %H:%M:%S'): $*"
    fi
}

show_help() {
    cat <<EOF
promptr - Prompt management tool v$VERSION

A CLI tool for managing and syncing prompt collections via Git.
Prompts live in $PROMPTS_HOME

Commands:
    update          Fetch and merge latest prompts from the remote repository
    self-update     Update the promptr script itself
    link            Create links for specific target or all (antigravity, codex, copilot, droid, opencode, claude, roo, all)
    unlink          Remove links for specific target or all (antigravity, codex, copilot, droid, opencode, claude, roo, all)

Link flags:
    --force         Remove existing destination symlink before recreating

Global flags:
    --version       Show version
    --help          Show this help message
    --verbose       Enable verbose logging

Usage: promptr [flags] [command] [flags]
EOF
}

show_version() {
    echo "promptr version $VERSION - Prompt collection manager."
}

require_repo() {
    if [ ! -d "$PROMPTS_HOME/.git" ]; then
        echo "❌ Prompt repository not found at $PROMPTS_HOME. Set PROMPTR_DIR to your clone (default ~/.prompts) or rerun the setup script with your repo URL."
        exit 1
    fi
}

check_self_loop() {
    local source_dir=$1
    local self_loop_link="$source_dir/$(basename "$source_dir")"

    if [ -L "$self_loop_link" ] && [ "$(readlink "$self_loop_link")" = "$source_dir" ]; then
        echo "❌ Found recursive symlink at $self_loop_link; remove it with: rm $self_loop_link"
        return 1
    fi

    return 0
}

ensure_config_dir() {
    mkdir -p "$CONFIG_DIR"
}

load_filename_prefix() {
    if [ -n "${PROMPTR_PREFIX:-}" ]; then
        ensure_config_dir
        echo -n "$PROMPTR_PREFIX" >"$PREFIX_FILE"
        echo "$PROMPTR_PREFIX"
        return
    fi

    if [ -f "$PREFIX_FILE" ]; then
        local stored_prefix
        stored_prefix=$(cat "$PREFIX_FILE")
        if [ -n "$stored_prefix" ]; then
            echo "$stored_prefix"
            return
        fi
    fi

    echo "$FILENAME_PREFIX_DEFAULT"
}

FILENAME_PREFIX="$(load_filename_prefix)"

is_target_linked() {
    local target=$1

    if [ ! -f "$LINKS_FILE" ]; then
        return 1
    fi

    grep -Fxq "$target" "$LINKS_FILE"
}

record_linked_target() {
    local target=$1

    ensure_config_dir

    if ! is_target_linked "$target"; then
        echo "$target" >>"$LINKS_FILE"
    fi
}

clear_linked_target() {
    local target=$1

    if [ ! -f "$LINKS_FILE" ]; then
        return 0
    fi

    local tmp_file
    tmp_file="$(mktemp "$LINKS_FILE.XXXXXX")"

    grep -Fxv "$target" "$LINKS_FILE" >"$tmp_file" || true
    mv "$tmp_file" "$LINKS_FILE"
}

clear_all_linked_targets() {
    rm -f "$LINKS_FILE"
}

validate_source_dir() {
    local source_dir=$1

    if [ ! -d "$source_dir" ]; then
        echo "❌ Cannot create symlink: source directory $source_dir is missing"
        return 1
    fi

    if [ -L "$source_dir" ]; then
        echo "❌ Cannot create symlink: $source_dir is itself a symlink (nested symlinks not allowed)"
        return 1
    fi

    check_self_loop "$source_dir"
}

guard_target_path() {
    local target_dir=$1
    local source_dir=$2

    if [ "$target_dir" = "$source_dir" ]; then
        echo "❌ Cannot link $target_dir to itself (would create recursive symlink)"
        return 1
    fi

    case "$target_dir" in
        "$source_dir"|"$source_dir"/*)
            echo "❌ Cannot create symlink inside $source_dir (would create recursive link at $target_dir)"
            return 1
            ;;
    esac

    local check_dir="$target_dir"
    while [ "$check_dir" != "/" ] && [ "$check_dir" != "." ] && [ "$check_dir" != ".." ]; do
        if [ -L "$check_dir" ]; then
            echo "❌ Cannot create symlink: path $target_dir contains symlink at $check_dir (would create nested symlinks)"
            return 1
        fi
        check_dir=$(dirname "$check_dir")
    done

    return 0
}

prepare_destination() {
    local destination=$1

    if [ -e "$destination" ] && [ "$FORCE" = false ]; then
        echo "❌ $destination already exists. Use --force to replace an existing symlink."
        return 1
    fi

    if [ "$FORCE" = true ] && [ -e "$destination" ] && [ ! -L "$destination" ]; then
        echo "❌ Cannot use --force: $destination exists and is not a symlink (refusing to remove)"
        return 1
    fi

    if [ "$FORCE" = true ] && [ -L "$destination" ]; then
        rm "$destination" || {
            echo "❌ Failed to remove existing symlink at $destination (needed for --force)"
            return 1
        }
    fi
}

create_symlink() {
    local target_dir=$1
    local link_name=$2
    local source_dir="$PROMPTS_HOME"
    local destination="$target_dir/$link_name"

    validate_source_dir "$source_dir" || return 1
    guard_target_path "$target_dir" "$source_dir" || return 1
    prepare_destination "$destination" || return 1

    mkdir -p "$target_dir"
    ln -s "$source_dir" "$destination"
    check_self_loop "$source_dir" || return 1
    echo "✅ Symlink created/updated at $target_dir/$link_name"
}

copy_antigravity_files() {
    local dest_dir="$ANTIGRAVITY_DIR"

    mkdir -p "$dest_dir"

    local files
    files=$(find "$PROMPTS_HOME" -name "*.md" ! -name "README.md" -type f)
    if [ -z "$files" ]; then
        echo "⚠️  No *.md files found in $PROMPTS_HOME"
        return 0
    fi

    echo "$files" | while IFS= read -r file; do
        local dest_file="$dest_dir/$(basename "$file")"
        if [ "$FORCE" = true ] && [ -e "$dest_file" ]; then
            rm -f "$dest_file"
        fi
        cp "$file" "$dest_file"
    done

    record_linked_target "antigravity"
    echo "✅ Copied *.md files to $dest_dir"
}

copy_roo_files() {
    local dest_dir="$HOME/.roo/commands"

    if [ "$FORCE" = true ]; then
        rm -rf "$dest_dir"/*
    fi

    mkdir -p "$dest_dir"

    local files
    files=$(find "$PROMPTS_HOME" -name "*.md" ! -name "README.md" -type f)
    if [ -z "$files" ]; then
        echo "⚠️  No *.md files found in $PROMPTS_HOME"
        return 0
    fi

    echo "$files" | while IFS= read -r file; do
        cp "$file" "$dest_dir"
    done

    echo "✅ Copied *.md files to $dest_dir"
}

copy_codex_files() {
    local dest_dir="$CODEX_DIR"

    mkdir -p "$dest_dir"

    local files
    files=$(find "$PROMPTS_HOME" -name "*.md" ! -name "README.md" -type f)
    if [ -z "$files" ]; then
        echo "⚠️  No *.md files found in $PROMPTS_HOME"
        return 0
    fi

    echo "$files" | while IFS= read -r file; do
        local dest_file="$dest_dir/${FILENAME_PREFIX}$(basename "$file")"
        if [ "$FORCE" = true ] && [ -e "$dest_file" ]; then
            rm -f "$dest_file"
        fi
        cp "$file" "$dest_file"
    done

    record_linked_target "codex"
    echo "✅ Copied prefixed *.md files to $dest_dir"
}

copy_droid_files() {
    local dest_dir="$DROID_DIR"

    mkdir -p "$dest_dir"

    local files
    files=$(find "$PROMPTS_HOME" -name "*.md" ! -name "README.md" -type f)
    if [ -z "$files" ]; then
        echo "⚠️  No *.md files found in $PROMPTS_HOME"
        return 0
    fi

    echo "$files" | while IFS= read -r file; do
        local dest_file="$dest_dir/${FILENAME_PREFIX}$(basename "$file")"
        if [ "$FORCE" = true ] && [ -e "$dest_file" ]; then
            rm -f "$dest_file"
        fi
        cp "$file" "$dest_file"
    done

    record_linked_target "droid"
    echo "✅ Copied prefixed *.md files to $dest_dir"
}

copy_copilot_files() {
    local dest_dir="$COPILOT_DIR"

    mkdir -p "$dest_dir"

    local files
    files=$(find "$PROMPTS_HOME" -name "*.md" ! -name "README.md" -type f)
    if [ -z "$files" ]; then
        echo "⚠️  No *.md files found in $PROMPTS_HOME"
        return 0
    fi

    echo "$files" | while IFS= read -r file; do
        local name_no_ext
        name_no_ext=$(basename "$file" .md)
        local dest_file="$dest_dir/${FILENAME_PREFIX}$name_no_ext.prompt.md"
        if [ "$FORCE" = true ] && [ -e "$dest_file" ]; then
            rm -f "$dest_file"
        fi
        cp "$file" "$dest_file"
    done

    record_linked_target "copilot"
    echo "✅ Copied prefixed *.prompt.md files to \"$dest_dir\""
}

unlink_antigravity() {
    local dest_dir="$ANTIGRAVITY_DIR"

    if [ ! -d "$dest_dir" ]; then
        return 0
    fi

    local files
    files=$(find "$PROMPTS_HOME" -name "*.md" ! -name "README.md" -type f)
    if [ -z "$files" ]; then
        return 0
    fi

    echo "$files" | while IFS= read -r file; do
        local dest_file="$dest_dir/$(basename "$file")"
        if [ -e "$dest_file" ]; then
            rm -f "$dest_file"
        fi
    done

    clear_linked_target "antigravity"
    echo "✅ Removed AntiGravity prompt copies from $dest_dir"
}

unlink_roo() {
    local dest_dir="$HOME/.roo/commands"

    if [ ! -d "$dest_dir" ]; then
        return 0
    fi

    local files
    files=$(find "$PROMPTS_HOME" -name "*.md" ! -name "README.md" -type f)
    if [ -z "$files" ]; then
        return 0
    fi

    echo "$files" | while IFS= read -r file; do
        local dest_file="$dest_dir/$(basename "$file")"
        if [ -e "$dest_file" ]; then
            rm -f "$dest_file"
        fi
    done

    clear_linked_target "roo"
    echo "✅ Removed Roo prompt copies from $dest_dir"
}

unlink_codex() {
    local dest_dir="$CODEX_DIR"

    if [ ! -d "$dest_dir" ]; then
        clear_linked_target "codex"
        return 0
    fi

    local files
    files=$(find "$PROMPTS_HOME" -name "*.md" ! -name "README.md" -type f)
    if [ -n "$files" ]; then
        echo "$files" | while IFS= read -r file; do
            local dest_file="$dest_dir/${FILENAME_PREFIX}$(basename "$file")"
            if [ -e "$dest_file" ]; then
                rm -f "$dest_file"
            fi
        done
    fi

    clear_linked_target "codex"
    echo "✅ Removed Codex prompt copies from $dest_dir"
}

unlink_droid() {
    local dest_dir="$DROID_DIR"

    if [ ! -d "$dest_dir" ]; then
        clear_linked_target "droid"
        return 0
    fi

    local files
    files=$(find "$PROMPTS_HOME" -name "*.md" ! -name "README.md" -type f)
    if [ -n "$files" ]; then
        echo "$files" | while IFS= read -r file; do
            local dest_file="$dest_dir/${FILENAME_PREFIX}$(basename "$file")"
            if [ -e "$dest_file" ]; then
                rm -f "$dest_file"
            fi
        done
    fi

    clear_linked_target "droid"
    echo "✅ Removed Droid prompt copies from $dest_dir"
}

unlink_copilot() {
    local dest_dir="$COPILOT_DIR"

    if [ ! -d "$dest_dir" ]; then
        clear_linked_target "copilot"
        return 0
    fi

    local files
    files=$(find "$PROMPTS_HOME" -name "*.md" ! -name "README.md" -type f)
    if [ -n "$files" ]; then
        echo "$files" | while IFS= read -r file; do
            local name_no_ext
            name_no_ext=$(basename "$file" .md)
            local dest_file="$dest_dir/${FILENAME_PREFIX}$name_no_ext.prompt.md"
            if [ -e "$dest_file" ]; then
                rm -f "$dest_file"
            fi
        done
    fi

    clear_linked_target "copilot"
    echo "✅ Removed Copilot prompt copies from \"$dest_dir\""
}

cmd_update() {
    require_repo

    log_verbose "Updating prompt repository at $PROMPTS_HOME..."
    if [ "$VERBOSE" = true ]; then
        git -C "$PROMPTS_HOME" status --short
    fi

    if git -C "$PROMPTS_HOME" pull ${VERBOSE:+--verbose}; then
        if is_target_linked "antigravity"; then
            log_verbose "Refreshing AntiGravity prompt copies..."
            copy_antigravity_files
        fi
        if is_target_linked "roo"; then
            log_verbose "Refreshing Roo prompt copies..."
            copy_roo_files
        fi
        if is_target_linked "copilot"; then
            log_verbose "Refreshing Copilot prompt copies..."
            copy_copilot_files
        fi
        if is_target_linked "codex"; then
            log_verbose "Refreshing Codex prompt copies..."
            copy_codex_files
        fi
        echo "✅ Prompts updated successfully at $PROMPTS_HOME."
    else
        echo "❌ Failed to update prompts. Check your connection and repository permissions."
        exit 1
    fi
}

cmd_self_update() {
    mkdir -p "$(dirname "$INSTALL_BIN")"

    local cli_url="${PROMPTR_CLI_URL:-https://raw.githubusercontent.com/mul14/promptr/master/bin/promptr}"
    echo "Downloading promptr from $cli_url ..."

    if command -v curl >/dev/null 2>&1; then
        curl -fsSL "$cli_url" -o "$INSTALL_BIN" || {
            echo "❌ Failed to download CLI from $cli_url. Set PROMPTR_CLI_URL to a valid URL and retry."
            exit 1
        }
    elif command -v wget >/dev/null 2>&1; then
        wget -qO "$INSTALL_BIN" "$cli_url" || {
            echo "❌ Failed to download CLI from $cli_url. Set PROMPTR_CLI_URL to a valid URL and retry."
            exit 1
        }
    else
        echo "❌ Neither curl nor wget is available to download the CLI."
        exit 1
    fi

    chmod +x "$INSTALL_BIN" || {
        echo "❌ Failed to set execute permission on $INSTALL_BIN"
        exit 1
    }
    echo "✅ Promptr script updated at $INSTALL_BIN."
}

show_link_usage() {
    echo "❌ Usage: promptr link [--force] <target|all>"
    echo "Supported targets:"
    echo "  antigravity    Copy *.md prompts to Gemini AI global workflows (~/.gemini/antigravity/global_workflows)"
    echo "  codex          Copy *.md prompts to Codex prompts directory (~/.codex/prompts) with configured prefix (default promptr-)"
    echo "  copilot        Copy *.md prompts to Copilot prompts directory (~/Library/Application Support/Code/User/prompts on macOS, ~/.config/Code/User/prompts on Linux) with configured prefix and .prompt.md suffix (default promptr-)"
    echo "  droid          Copy *.md prompts to Droid commands directory (~/.factory/commands) with configured prefix (default promptr-)"
    echo "  opencode       Create symlink for OpenCode command prompts (~/.config/opencode/command/promptr)"
    echo "  claude         Create symlink for Claude commands (~/.claude/commands/promptr)"
    echo "  roo            Copy *.md files to Roo commands directory (~/.roo/commands)"
    echo "  all            Link all targets (copy for AntiGravity/Roo/Droid/Copilot/Codex, symlink for OpenCode/Claude)"
}

cmd_link() {
    require_repo

    if [ -z "$TARGET_ARG" ]; then
        show_link_usage
        exit 1
    fi

    local status=0
    case $TARGET_ARG in
        all)
            copy_antigravity_files || status=1
            create_symlink "$HOME/.config/opencode/command" promptr && record_linked_target "opencode" || status=1
            create_symlink "$HOME/.claude/commands" promptr && record_linked_target "claude" || status=1
            copy_roo_files && record_linked_target "roo" || status=1
            copy_droid_files || status=1
            copy_copilot_files || status=1
            copy_codex_files || status=1
            ;;
        antigravity)
            copy_antigravity_files || status=1
            ;;
        codex)
            copy_codex_files || status=1
            ;;
        droid)
            copy_droid_files || status=1
            ;;
        copilot)
            copy_copilot_files || status=1
            ;;
        opencode)
            create_symlink "$HOME/.config/opencode/command" promptr && record_linked_target "opencode" || status=1
            ;;
        claude)
            create_symlink "$HOME/.claude/commands" promptr && record_linked_target "claude" || status=1
            ;;
        roo)
            copy_roo_files && record_linked_target "roo" || status=1
            ;;
        *)
            echo "❌ Unknown target: $TARGET_ARG"
            show_link_usage
            exit 1
            ;;
    esac

    if [ $status -ne 0 ]; then
        exit 1
    fi
}

show_unlink_usage() {
    echo "❌ Usage: promptr unlink <target|all>"
    echo "Supported targets:"
    echo "  antigravity    Remove copied prompts from ~/.gemini/antigravity/global_workflows"
    echo "  codex          Remove prefixed copied prompts from ~/.codex/prompts (uses configured prefix, default promptr-)"
    echo "  copilot        Remove prefixed copied prompts (.prompt.md) from Copilot prompts directory (~/Library/Application Support/Code/User/prompts on macOS, ~/.config/Code/User/prompts on Linux) using configured prefix (default promptr-)"
    echo "  droid          Remove prefixed copied prompts from ~/.factory/commands (uses configured prefix, default promptr-)"
    echo "  opencode       Remove symlink at ~/.config/opencode/command/promptr"
    echo "  claude         Remove symlink at ~/.claude/commands/promptr"
    echo "  roo            Remove copied prompts from ~/.roo/commands"
    echo "  all            Remove all managed links and copies"
}

remove_symlink_target() {
    local target_dir=$1
    local link_name=$2
    local destination="$target_dir/$link_name"

    if [ -L "$destination" ]; then
        rm "$destination" || {
            echo "❌ Failed to remove symlink at $destination"
            return 1
        }
        echo "✅ Removed symlink at $destination"
    fi
}

cmd_unlink() {
    if [ -z "$TARGET_ARG" ]; then
        show_unlink_usage
        exit 1
    fi

    local status=0
    case $TARGET_ARG in
        all)
            unlink_antigravity || status=1
            remove_symlink_target "$HOME/.config/opencode/command" promptr || status=1
            clear_linked_target "opencode"
            remove_symlink_target "$HOME/.claude/commands" promptr || status=1
            clear_linked_target "claude"
            unlink_roo || status=1
            unlink_droid || status=1
            unlink_copilot || status=1
            unlink_codex || status=1
            clear_all_linked_targets
            ;;
        antigravity)
            unlink_antigravity || status=1
            ;;
        codex)
            unlink_codex || status=1
            ;;
        droid)
            unlink_droid || status=1
            ;;
        copilot)
            unlink_copilot || status=1
            ;;
        opencode)
            remove_symlink_target "$HOME/.config/opencode/command" promptr || status=1
            clear_linked_target "opencode"
            ;;
        claude)
            remove_symlink_target "$HOME/.claude/commands" promptr || status=1
            clear_linked_target "claude"
            ;;
        roo)
            unlink_roo || status=1
            ;;
        *)
            echo "❌ Unknown target: $TARGET_ARG"
            show_unlink_usage
            exit 1
            ;;
    esac

    if [ $status -ne 0 ]; then
        exit 1
    fi
}

parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --version)
                show_version
                exit 0
                ;;
            --help|-h)
                show_help
                exit 0
                ;;
            --verbose)
                VERBOSE=true
                shift
                ;;
            *)
                COMMAND=$1
                shift
                while [[ $# -gt 0 ]]; do
                    case $1 in
                        --verbose)
                            VERBOSE=true
                            shift
                            ;;
                        --force)
                            FORCE=true
                            shift
                            ;;
                        -*)
                            echo "❌ Unknown flag: $1"
                            echo "Run 'promptr --help' for usage."
                            exit 1
                            ;;
                        *)
                            if [ -z "$TARGET_ARG" ]; then
                                TARGET_ARG=$1
                                shift
                            else
                                echo "❌ Unexpected argument: $1"
                                echo "Run 'promptr --help' for usage."
                                exit 1
                            fi
                            ;;
                    esac
                done
                break
                ;;
        esac
    done
}

main() {
    parse_args "$@"

    case "$COMMAND" in
        "")
            show_help
            exit 0
            ;;
        update)
            cmd_update
            ;;
        self-update)
            cmd_self_update
            ;;
        link)
            cmd_link
            ;;
        unlink)
            cmd_unlink
            ;;
        *)
            echo "❌ Unknown command: $COMMAND"
            echo "Run 'promptr --help' for available commands."
            exit 1
            ;;
    esac
}

main "$@"
